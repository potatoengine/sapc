%prefix "sapc"
%header {
    #include "context.h"
}
%source {
    static int re_next(struct reParseContext* ctx) {
        if (ctx->loc.position >= ctx->length)
            return -1;

        return ctx->source[ctx->loc.position++];
    }

    static int re_line(char const* str, size_t position) {
        int line = 1;
        for (size_t index = 0; index != position; ++index)
            if (str[index] == '\n')
                ++line;
        return line;
    }

    #define PCC_GETCHAR(state) re_next((state))
    #define PCC_ERROR(auxil) reError((auxil)->state, (struct reLoc){(auxil)->loc.position, re_line((auxil)->source, (auxil)->loc.position)}, "parse error")
    #define RE_LOC (auxil->loc)
    #define RE_STATE (auxil->state)
    #define RE_FAIL(pos, msg) (reError((auxil)->state, (struct reLoc){(pos), re_line((auxil)->source, (pos))}, (msg)))
}
%auxil "struct reParseContext*"
%value "struct reID"

# file
file <- _ module ( _ statement )* _ !. ~{ reError(RE_STATE, RE_LOC, "failed to parse input"); }
statement <- ( attrdef / typedef / import / include )
module <- 'module' _ m:identifier _ ';' { reModuleName(RE_STATE, m, RE_LOC); }

# import/include
import <- 'import' _ f:identifier _ ';' { reImport(RE_STATE, f, RE_LOC); }
include <- 'include' _ p:string space? linecomment? eol { reInclude(RE_STATE, p, RE_LOC); } eol

# values
value <- v:number { $$ = v; } / v:string { $$ = v; } / v:true { $$ = v; } / v:false { $$ = v; } / v:null { $$ = v; }
number <- <'-'? [0-9]+> { $$ = rePushNumber(RE_STATE, $1); }
string <- '"' <[^"\n]*> '"' { $$ = rePushString(RE_STATE, $1); }
true <- 'true' { $$ = rePushBoolean(RE_STATE, 1); }
false <- 'false' { $$ = rePushBoolean(RE_STATE, 0); }
null <- 'null' { $$ = rePushNull(RE_STATE); }

# common
_ <- ( space / eol / comment )*
eol <- '\n' { auxil->loc.line++; }
space <- [ \t]+
comment <- linecomment eol / blockcomment
linecomment <- ( '//' / '#' ) [^\n]*
blockcomment <- '/*' ( eol / !'*/' . )* '*/' ~{ RE_FAIL($0s, "invalid block comment"); }
identifier <- <[a-zA-Z_][a-zA-Z0-9_]*> { $$ = rePushIdentifier(RE_STATE, $1); }
initializer <- _ '=' _ v:value { $$ = v; } / { $$ = RE_NONE; }

# attribute definitions
attrdef <- 'attribute' _ n:identifier _ ( '{' (_ attrparam )* _ '}' / ';' ) { rePushAttributeDefinition(RE_STATE, n, RE_LOC); }
attrparam <- t:identifier _ n:identifier v:initializer _ ';' { rePushAttributeParam(RE_STATE, t, n, v, RE_LOC); }

# attributes
attributes <- ( '[' _ attribute ( _ ',' _ attribute )* _ ']' )+
attribute <- n:identifier ( _ '(' _ ( attrarg ( _ ',' _ attrarg )* )? _ ')' )? { rePushAttribute(RE_STATE, n, RE_LOC); }
attrarg <- v:value { rePushAttributeArgument(RE_STATE, v); }

# types
typedef <- attributes? { rePushAttributeSet(RE_STATE); } _ 'type' _ n:identifier _ b:typebase? _ ( '{' ( _ field )* _ '}' / ';' ) { rePushTypeDefinition(RE_STATE, n, b, RE_LOC); }
typebase <- ':' _ n:identifier { $$ = n; } / { $$ = RE_NONE; }
field <- attributes? { rePushAttributeSet(RE_STATE); } _ t:identifier _ n:identifier v:initializer _ ';' { rePushField(RE_STATE, t, n, v, RE_LOC); }

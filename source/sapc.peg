%prefix "sapc"
%header {
    #include "context.h"
}
%source {
    static int re_next(struct reParseContext* ctx) {
        if (ctx->loc.position >= ctx->length)
            return -1;

        return ctx->source[ctx->loc.position++];
    }

    static struct reLoc re_loc(char const* str, size_t position) {
        int line = 1;
        size_t line_start = 0;
        for (size_t index = 0; index != position; ++index) {
            if (str[index] == '\n') {
                line_start = position;
                ++line;
            }
        }
        return (struct reLoc){position, line_start, line};
    }

    #define PCC_GETCHAR(state) re_next((state))
    #define PCC_ERROR(auxil) do{if((auxil)->errors==0){++(auxil)->errors;reError((auxil)->state, re_loc((auxil)->source, (auxil)->loc.position), "failed to parse input");}}while(0)
    #define RE_LOC (auxil->loc)
    #define RE_STATE (auxil->state)
    #define RE_FAIL(pos, msg) do{++(auxil)->errors;reError((auxil)->state, re_loc((auxil)->source, (pos)), (msg));}while(0)
}
%auxil "struct reParseContext*"
%value "struct reID"

# file
file <- _ module ( _ pragma )* ( _ statement )* _ !.
statement <- ( attrdef / typedef / enumdef / import / include )
module <- 'module' _ m:identifier _ ';' { reModuleName(RE_STATE, m, RE_LOC); } ~{ RE_FAIL($0s, "missing module declaration"); }
pragma <- 'pragma' _ i:identifier _ ';'

# import/include
import <- 'import' _ f:identifier _ ';' { reImport(RE_STATE, f, RE_LOC); }
include <- 'include' _ p:string space? linecomment? eol { reInclude(RE_STATE, p, RE_LOC); } eol

# values
value <- ( v:number { $$ = v; } / v:string { $$ = v; } / v:true { $$ = v; } / v:false { $$ = v; } / v:null { $$ = v; } / v:identifier { $$ = v; } ) ~{ RE_FAIL($0s, "expected value"); }
number <- <'-'? [0-9]+> { $$ = rePushNumber(RE_STATE, $1); }
string <- '"' <[^"\n]*> '"' { $$ = rePushString(RE_STATE, $1); }
true <- 'true' { $$ = rePushBoolean(RE_STATE, 1); }
false <- 'false' { $$ = rePushBoolean(RE_STATE, 0); }
null <- 'null' { $$ = rePushNull(RE_STATE); }

# common
_ <- ( space / eol / comment )*
eol <- '\n' { auxil->loc.line++; auxil->loc.line_start = auxil->loc.position; }
space <- [ \t]+
comment <- linecomment eol / blockcomment
linecomment <- ( '//' / '#' ) [^\n]*
blockcomment <- '/*' ( eol / !'*/' . )* '*/' ~{ RE_FAIL($0s, "invalid block comment"); }
identifier <- <[a-zA-Z_][a-zA-Z0-9_]*> { $$ = rePushIdentifier(RE_STATE, $1); }
initializer <- '=' _ v:value { $$ = v; } / { $$ = RE_NONE; }

# attribute definitions
attrdef <- 'attribute' _ n:identifier _ ( '{' (_ attrparam )* _ '}' / ';' ) { rePushAttributeDefinition(RE_STATE, n, RE_LOC); }
attrparam <- t:identifier _ n:identifier _ v:initializer _ ';' { rePushAttributeParam(RE_STATE, t, n, v, RE_LOC); }

# attributes
attributes <- ( '[' _ attribute ( _ ',' _ attribute )* _ ']' )* { rePushAttributeSet(RE_STATE); }
attribute <- n:identifier ( _ '(' _ ( attrarg ( _ ',' _ attrarg )* )? _ ')' )? { rePushAttribute(RE_STATE, n, RE_LOC); }
attrarg <- v:value { rePushAttributeArgument(RE_STATE, v); }

# types
typedef <- attributes _ 'type' _ n:identifier _ b:typebase? _ ( '{' ( _ field )* _ '}' / ';' ) { rePushTypeDefinition(RE_STATE, n, b, RE_LOC); }
typebase <- ':' _ n:identifier { $$ = n; } / { $$ = RE_NONE; }
field <- attributes _ t:identifier _ p:fieldptr _ a:fieldarray _ n:identifier _ v:initializer _ ';' { rePushField(RE_STATE, t, p, a, n, v, RE_LOC); }
fieldptr <- '*' { $$ = rePushBoolean(RE_STATE, 1); } / { $$ = rePushBoolean(RE_STATE, 0); }
fieldarray <- '[]' { $$ = rePushBoolean(RE_STATE, 1); } / { $$ = rePushBoolean(RE_STATE, 0); }

# enumerations
enumdef <- attributes _ 'enum' _ n:identifier _ b:typebase? _ '{' _ enumvalue ( _ ',' _ enumvalue )* _ '}' { rePushEnumDefinition(RE_STATE, n, b, RE_LOC); }
enumvalue <- i:identifier _ v:enuminit { rePushEnumValue(RE_STATE, i, v, RE_LOC); }
enuminit <- '=' _ n:number { $$ = n; } / { $$ = RE_NONE; }
